\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{verbatim}
\usepackage{float}
\newcommand{\myfloatalign}{\centering}
\usepackage[ruled]{algorithm2e}
\usepackage{graphicx,color,url}
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.


\begin{document}

\title{Speeding up evaluation of structures for the Angry Birds Game}

\author{\authorname{First Author Name\sup{1}\orcidAuthor{0000-0000-0000-0000}, Second Author Name\sup{1}\orcidAuthor{0000-0000-0000-0000} 
and Third Author Name\sup{2}\orcidAuthor{0000-0000-0000-0000}}
\affiliation{\sup{1}Place Holder, XYZ University, My Street, MyTown, MyCountry}
\affiliation{\sup{2}Place Holder, Main University, MySecondTown, MyCountry}
\email{\{f\_author, s\_author\}@ips.xyz.edu, t\_author@dc.mu.edu}
}

\keywords{Search-Based Procedural Content Generator, Evolutionary algorithm, 
Game development, Angry Birds, Level generation }

\abstract{
	In this work, we present an original method based on evolutionary algorithms for generating basic structures for the physics-based game Angry Birds, with the ultimate objective of creating Angry Birds levels with the minimum number of constraints. We must generate structures that remain stable under gravity, in order to be playable in the game. We have designed and implemented an open source evolutionary computation library,  with a fitness function designed to  first, avoid if possible the an actual simulation of a game, which is time-consuming, and, then, to take into account the different ways in which a structure is not sound and consider how to achieve that soundness. We have experimented with different representations and evolutionary operators. In order to evaluate the algorithm,  we carried out six experiments, obtaining a wide variety of stable structures. These structures are the basis for generating levels that are aesthetically pleasing as well as playable.
}

\onecolumn \maketitle \normalsize \setcounter{footnote}{0} \vfill

\section{\uppercase{Introduction}}
\label{sec:intro}
\textit{Angry Birds} is a multiplatform video game created in 2009 by
the Rovio Entertainment  Corporation. Each level of the game consists
of a collection of structures made out of blocks in which comic  {\em
  pig} characters are hiding;  the player has to fire from a slingshot
different {\em bird} characters, each having different abilities and
moods.  The objective of the game is to destroy all the pigs by
knocking down the structures or just hitting them directly.  The game
relies on gravity to create interesting puzzles by closely resembling
the dynamics of real-world structures. It has been approached in
different ways from the computational intelligence community; in this
paper we are interested in generating levels that are playable and
interesting. This has been proposed as a competition in several
game-related conferences
\cite{AngryBirds_LevelGeneration_18,GAIG_LevelGeneration_18}, but
could be also interesting from the perspective of generating levels
to train or evaluate game-playing bots, as was done by Zafar et al. in
\cite{zafar2019corpus}.

Search-based Procedural Content Generation (SBPCG) is a type of a
\textit{generate-and-test} approach to PCG which is usually tackled
with Evolutionary Algorithms(EA) \cite{togelius2010search}. The
challenges faced by SBPCG are not far from those found in EAs; since
they are search methods, they can be a good option to perform this
kind of systems. In our case, as a first step to generate Angry Birds
levels, we will generate free-form self-standing structures using the Angry
Birds basic blocks. The main intention with this approach is to
eventually generate structures that can host {\em pigs} and that
achieve aesthetic quality mainly through variability and the fact that
they are not cookie-cutter repetitions of the same basic structure
with some small variations; at the same time
it becomes an interesting and challenging problem from the
optimization point of view: using some basic building blocks and a
simulated gravity, be able to generate structures that do not
collapse. That is the main objective of this line of work.

The primery objective of this paper, however, is to use a fitness function that is
able to evaluate structures without needing the simulator, advancing
the state of the art with respect to our previous paper
\cite{DBLP:conf/evoW/CalleGGV19}, where we needed to use the simulator
itself to check gravity, which incurred in a lot of overhead, up to
several seconds.

In this paper, we will use what \cite{togelius2010search} calls {\em
  direct fitness function}, this function computes a score from
measurable features of the generated content.However, this fitness
function is a time-consuming task since it involves the generation of
a graphic representation of the structure and the simulation of the
falling motion. If we have to evaluate every single individual in the
population, we will not be able to cover enough of the free-form
search space to find a good enough solution. So we must minimize the
actual number of structures that are simulated by applying heuristics
to the data structure and assigning it a fitness even before the
simulation. 


This paper is organized as follows: in the next section, we present
the state of the art in this type of level generation, as well as its
relation to the problem of generating structurally sound
structures. Our proposed method for generating Angry Birds levels is
described next in Section \ref{sec:angry}. Next experiments are
presented in section \ref{ch:res}. We present our conclusions in
\ref{sec:conclusions}.  


\section{Background and State of the Art}
\label{sec:soa}

PCG used for video game levels is relevant in international artificial
intelligence competitions, such as Super Mario Level Generation
\cite{MarioAI_Level_12}, General Video Games
\cite{GAIG_LevelGeneration_18,Khalifa_GVGLG_16}, or recently, for
Angry Birds \cite{AngryBirds_LevelGeneration_18}. This work is related
to works presented in previous editions of the competition.  The focus
of the latest edition \cite{AngryBirds_LevelGeneration_18} was on
finding entertaining levels. Fun was the main factor in the evaluation
of proposals; secondary factors were creativity and difficulty.  Six
entries participated, of which J. Yuxuan et al., were able to generate
random quotations with different components of a level; J. Xu et
al. generated levels that look like pixel images. A third approach (by
C. Kocaogullar) translated music patterns to generate structures. The
winner was {\em Iratus Aves}, a new iteration of the work by M. Stephenson
and J. Renz \cite{stephenson2017generating,stephenson2016procedural},
which follows a \textit{constructive method}. In this work, the
likelihood of selecting a certain block is given by a probability
table, which was tuned using an optimization method. Blocks are then
stacked following a tree structure.

A constructive method ensures local stability, but not global
stability, which must be evaluated once the whole structure is
completed. One problem with this and other constructive approaches is
that the variety of structures created is going to be relatively
small; monotony leads to boredom, decreasing playability. On the other
hand, generated structures are guaranteed to be structurally sound,
and constructive approaches are generally faster than search-based
procedures. 


An alternative to deal with these limitations is to follow a
\textit{Search-based approach}. Thus, Lucas Ferreira and Claudio
Toledo \cite{ferreira2014search} presented a solution using a Genetic
Algorithm (GA) and a game clone named \textit{Science Birds} developed
to evaluate the levels, the same one we use in this paper. Their work
was 4th on the last competition. In this GA, levels correspond to
individuals in a population, each individual has a chromosome
represented by an array of lists. Each list is a sequence of blocks,
pigs and predefined compound blocks, using an identification
number. Each list is then placed as a stack of elements in the game. A
level has several such stacks. This representation also includes the
distances between stacks. The population is initialized randomly
following a probability table defining the likelihood of a certain
element being placed in a certain position within a stack. This
implies that a column or stack shape is chosen beforehand, once again
ensuring stability, but decreasing playability by generating
structures whose only differences are which blocks are placed on top
of which. 

Levels are evaluated executing them in the simulator and checking
their average stability, considering the speed of every block when
erected -- which must tend to be zero when having a stable structure
--. The authors designed specialized crossover and mutation operators,
aiming to maintain the consistency of newly generated solutions.

The approach proposed by Stephenson et al. \cite{stephenson2019agent}
is based on agents, and is focused on offering custom experience for
specific players. 

However, this work proposes a different approach: \textit{free-form
  evolution}.  If we look outside the domain of game development and
focus on structural optimization in architecture, there are several
proposals using search-based algorithms. We can find a metaheuristic
called Cuckoo Search \cite{gandomi2013cuckoo} which performance was
tested with structural optimization. However, this optimization is
heavily parametrized and we are looking for the evolution of
structures that do not follow a predefined pattern.  Another approach
for structure design is using Generative Grammatical Encodings
\cite{hornby2001advantages} where L-system and its production rules
are considered individuals. This method increases the number of
generated patterns,  but still restrains the formation of disjoint
structures, for instance, a defensive tower before a simple pigsty in
our context. 

We aim at following a realistic structure generation approach, without
constraining it to a fixed form, thus advancing the state of the art
by allowing the creation of Angry Birds levels having any
arrangement. The next section will describe how we characterize this
problem and our approach to it. In our previous paper
\cite{DBLP:conf/evoW/CalleGGV19} we explored this approach and found
as one of its shortcomings the fact that the evaluation of generated
structures through the simulator was lengthy and didn't leave the
algorithm enough time to explore the search space. In this paper, we
try to tackle that problem, as well as take additional steps to
increase the complexity of generated structures. 

\section{Problem Description}
\label{sec:angry}

Science Birds is nowadays the main open source Angry Birds
simulator. It was developed by  Ferreira and Toledo
\cite{ferreira2014search}, and is available from
GitHub. We used it  as a starting point; however we
had to patch it for producing usable output 
and automate its work. The modified 
version is available on GitHub \url{https://github.com/Laucalle/ScienceBirds}. It produces output 
containing the position and average magnitude of the velocity of each block 
that was not broken after the simulation. It can be run from beginning to end 
without user interaction and minimizes the amount of time spent on simulating 
each level. 

In later experiments we will use Box2D (\url{https://box2d.org}), the
Physics engine, written in C++, originally 
used for the actual Angry Birds game, to avoid launching the whole
game which adds overhead to the fitness evaluation. In this 
simulation we do not have the resistance of the blocks implemented but we can test
the level stability much more efficiently, since there is no overhead computing things
unrelated to Physics, such as the graphic interface itself. This means we cannot penalize levels per broken block.

%\subsection{Evolutionary Algorithm}\label{ch:Representation}

Once the simulator that is going to be used to measure fitness is
ready, we have to design the fitness function. As obvious as it
might seem, the main feature of a stable level is that it 
is not in motion, so it seems reasonable to evaluate its whole stillness as opposed to its speed -- considering every single block --.

$$fitness_{ind} = \frac{1}{|V|}\sum_{i=0}^{b}{V_i} + P_{broken}\cdot(b-|V|)$$

In this version, the game engine provides the average magnitude of
velocity for each block. 
This set is noted as $V$, with $|V|$ being the cardinality of the
set.  $b$  is the number of blocks in an individual and it can differ
from the cardinality of $V$ since collapsed blocks are not tracked. The
number of broken blocks is $b-|V|$ and it is multiplied by a
penalization factor, since a level whose blocks break without user
interaction would not be considered valid. This happens when a block
free-falls from a certain height or collides with a falling object. 
$P_{broken}$ is set to $100$ since objects in a level do not usually reach that 
velocity, therefore it will separate non-valid levels from potentially good 
ones.

In the sixth experiment this fitness function is changed to the
following function after observing the results for the previous
experiment, al of them described in section \ref{ch:res}: 
$$fitness_{indV2} = \max{(V)}$$
% When we say length of a vector, we think about the norm (the actual lenght) 
% for instance the hypotenuse in a 2D vector. I think here we are talking about 
%the
% number of elements. If V is a set, then the cardinality |V| is right. 
% From your "calculateFitness" this is len so it is a list. 
% I was confused because we are talking about magnitude, velocity, etc. 
% Consider changing the name of V to an ordered set? - Mario
% Done - Laura


Either way, simulating a level is quite time consuming, on the order of
seconds using the game, which makes it almost unfeasible for our purpose, so we
decided to take additional factors on the fitness so that not all
levels are actually simulated. 
%Although we may know that a given level will perform poorly in the simulation, 
%removing it from the population will cause a high loss of diversity.
For that reason, before testing a level, there are some indicators, like
distance to the ground and number of overlapping blocks, that a level would 
not be a valid solution
% Antonio - what do you mean? It is not clear.
and thus simulation can be skipped.

If the object closest to the ground is far above, it is very likely that
it, along with all the others blocks above, 
will collapse from the impact. Levels that have all their blocks higher than a 
certain threshold will not be simulated by the engine. The threshold used is 
$0.1$ in game units and the penalty applied to the distance in order
to compute the fitness value is $10$:
$$f_{distance} = 
\begin{cases}
P_{distance}\cdot D_{lowest}, & \text{if } D_{lowest} > threshold\\
0, & \text{otherwise}
\end{cases}
$$

The other measure is the number of overlapping blocks. The separating axis 
theorem \cite{ericson2004real} determines if two convex shapes intersect. It is 
commonly used in game development for detecting collisions. A level with blocks 
that occupy the same space is not likely to be stable, as the Unity
Engine underlying the simulator will solve the issue moving the blocks
until there is no collision, but this is done by Unity proprietary
code and it is not possible to know what it does. 
% Since Unity 
% Engine is not open source and there is no documentation on how exactly those 
% collisions are solved, we assume that a precise prediction of the positions of 
% the blocks is not possible and therefore the fitness value obtained could be 
% inaccurate.
So, a penalty is applied and the level is not simulated either. 
In this case it is $f_{overlapping} = P_{overlapping} \cdot N_{overlapping}$ 
where the first factor is a penalty set to $10$ and the second is the number of 
blocks that overlap with each other.

In some of the late experiments we will substitute the $f_{distance}$
with the gap in the Y-axis.
We project all blocks on the Y-axis and calculate the range of values for the Y coordinate
that are not covered inside the feasible range. This is treated the same way as $f_{distance}$
(same penalization and threshold) and we call it $f_{Y-axis}$:
$$f_{Y-axis} = 
\begin{cases}
P_{distance}\cdot Pr_{Y-axis}, & \text{if } Pr_{Y-axis} > threshold\\
0, & \text{otherwise}
\end{cases}
$$

If both $f_{distance}$ and $f_{overlapping}$ are $0$ then the level is suitable 
for simulation and fitness is calculated as $fitness_{ind}$. This would be 
considered \textit{overpenalization} but exploring unfeasible regions entails a 
serious overhead that we need to minimize \cite{runarsson2003evolutionary}. 
On the other hand, levels with 
multiple blocks broken during the simulation are not feasible either but 
running the simulation is necessary. In this case, the penalization does not 
prevent the region to be explored.

Since one of the objectives of this work is to explore the expressiveness 
and variability of SBPCG, it seems reasonable to use a flexible representation. 
We will test these solutions to allow a less directed search than previous solutions while keeping a 
simple representation. 

Individuals are composed of a list of blocks; platforms, TNT boxes or pigs are not considered in this 
paper, since we are focused on the generation of structures. These
building blocks have the following attributes:

\begin{itemize}
	\item Type: there are eight regular blocks that can be placed in the level 
	with distinct shapes or sizes; they are represented as an
        integer between $0$ and $7$.
	\item Position: coordinates $x$ and $y$ of the centre of the block in game 
	units.
	\item Rotation: rotation of the block in degrees. Four different 
	rotation angles are considered: 0, 45, 90 or 135 degrees represented as integers 
	between $0$ and $3$.
        \item Material: three types, which determine the durability 
of the block. However, this does not affect their stability, so it will remain 
constant for now as \textit{wood} material.
\end{itemize}

Using this representation a gene representing a single block will be formed by two integers and two floating point numbers.
% Implementation detail, possibly irrelevant.
% The position of the corners of the block is frequently required, so it is 
%stored along with those attributes even though it can be calculated using the 
%size, the position and rotation of the block. (back to 16 pages with this)

Individuals are a collection of genes, in the same way a level is a collection 
of building blocks. The number of blocks is variable and the order in which 
they are listed is not important. 

The fitness of the worst individual that has been tested in game is
stored, so that the value of not tested levels is always above ---it is a minimization problem--- the in-game 
tested levels; the starting point for fitness of such individuals is the 
worst in-game score.

This penalization is calculated using the distance of the lowest block to the 
ground, which can be easily obtained, and the number of blocks that collide. 
This requires a bit more of computation, so it will be stored and set in the 
initialization of the individual. When a gene is modified, the number of 
overlapping blocks is recalculated for that specific change.

Considering all of the above, the chromosome object is composed by:
\begin{itemize}
	\item A list of genes.
	\item A fitness value.
	\item A penalty (set to {\tt False} for in-game evaluated levels).
	\item Number of overlapping blocks (calculated).
\end{itemize} % not sure these implementation details should be
              % included. Let's leve them, but if space is in short
              % supply, we can eliminate - JJ

%\subsection{Genetic Operators}

Initialization is done randomly, with each individual having a random number of 
genes, which are initialized by several methods: 

\begin{itemize}
	\item Random: selects a random number for each attribute of the gene.
	\item No Overlapping: also selects a random number but the gene is only 
	added to the chromosome if it does not overlap with an already existing 
	gene.
	\item Discrete: selects a random number for type and rotation, but the 
	position must be multiple of the dimensions of the smallest block (blocks 
	will be aligned).
	\item Discrete without overlapping: it combines the second and third 
	initialization method.
	\item Discrete with a set of pre configured blocks: first it includes
	a set of blocks, and then adds blocks following the third method until
	it reaches the desired number of blocks. The configurations used are the
	compound blocks found in \cite{ferreira2014search}.
\end{itemize}

Candidates for reproduction are selected using tournaments. Two individuals are chosen from the 
population and the best will be a parent in this generation. This is 
repeated until a certain percentage of pairs have been reached. It is important 
to note that individuals chosen are not removed from the population and 
therefore they can appear several times in the list of parents. 
% Is there a reason for this? For small populations some individual could
% be the parent of every member of the next generation :)  - Mario
% The reason was we were getting very poor results, beacuse we start with very 
%few fairly good individuals. Should this be mentioned here? - Laura
% Yes, you should mention it. Beacuse this a good problem for future work. 
% For instance you could try to do this only at the begining and after several
% generations change it to something not as extreme. This means that the 
%parameters
% of the algorithm are dynamic or adapted. - Mario
% OK, I added it to the Future Work section. 

Once the parents have been selected, we implement two different methods of 
combination:
\begin{itemize}
	\item Sample Crossover: gives a single individual per parent pair. It takes 
	all genes from both parents---excluding genes that are repeated---and 
	randomly takes a number of them to create the new individual. The number of 
	blocks is the minimum between the maximum number of blocks allowed, the 
	mean of the two parent individuals and the number of distinct genes.
	\item Common Blocks: produces two individuals. The common genes to both 
	parents are passed on to both children. The remaining genes are randomly 
	distributed to each child, half to one and half to the other. 
	\label{ga:cross2}
\end{itemize}

There are four different mutations:

\begin{itemize}
	\item Rotation: rotation is represented as an integer (it is discretized), 
	so it adds or 
	subtracts one 
	to the current value. % If types follow a logical order, you
                              % should mention it. If they don't, this
                              % is the same as generating a random
                              % number - JJ
                              % it makes more sense for rotation than it does 
                              % for type actually - Laura
	\item Type: similarly to rotation mutation.
	\item Position X: a real value between $0$ and $1$---excluding $0$---is 
	added or subtracted from the value of the position X.
	\item Position Y: same as position X mutation, for position Y.
\end{itemize}

They are all applied to random members of the population.

The new generation is selected using an elitist strategy. Best individuals in 
both the old population and their offspring pass on the next generation, 
maintaining the size of the population.

The information that describes a level can be too complex to have a binary 
representation as pure genetic algorithms suggest, so the framework should be 
flexible enough to support complex data structures. This prevented us from using other 
frameworks
and therefore a new framework was created. The source  code can be
found on GitHub at \url{https://github.com/Laucalle/AngryBirdsLevelGenerator}. % Is this true?

In order to evaluate the different options and check if they meet our
objective, we performed a series of experiments presented in next
section. 

%************************************************
\section{Experiments and Results}\label{ch:res}

We set out to evolve free-form structures, but we need to test, one by
one, the different parts of our algorithm: fitness function, some
evolutionary algorithm parameters and the genetic operators. In order
to do so, we performed a set of experiments to test our hypotheses,
whose result is shown in Table \ref{t:resOver1} shows an overview of the results. 

\begin{table}
	\myfloatalign
	\begin{tabular}{cclcl}
		& \textbf{Time(h)} &$\sigma$ & \textbf{G}& $\sigma$ \\ \hline
		\textbf{E1}&0.89&(0.59)&100.0&(0)\\  \hline
		\textbf{E2}&1.002&(1,97)&155.087&(240.56) \\  \hline
		\textbf{E3}&1.76&(0.6)&76.625&(42.3)\\  \hline
		\textbf{E4}&5.03&(1.46)&365.929&(158.09)  \\  \hline
		\textbf{E5}&0.099&(0.1)&121.2&(96.89)     \\  \hline 
		\textbf{E6}&0.788&(0.124)&1000.0&(0) \\  \hline
		% If possible, add standard deviation here - JJ
		% I could not find the original spreadsheet, I only have the raw data. I could 
		%%% not add standard deviation on time - Laura
		\hline
	\end{tabular}
	\caption{Summary of the execution of the last generation in 15-20 runs for each
		experiment. 40 runs for E5 and E6.
		G: number of generations, E: experiment 
		number} % What
	\label{t:resOver1}
\end{table}

\begin{table*}
	\myfloatalign
	\begin{tabular}{cclclcl}
		& \textbf{Best}& $\sigma$  &\textbf{Avg}&$\sigma$  & \textbf{Worst}&$\sigma$ \\ \hline
		\textbf{E1}&61.334&(133.02)&383.701&(106.14)&510.515&(133.04)\\  \hline
		\textbf{E2}&110.66&(142.21)&327.547&(238.33)&367.895&(260.83)  \\  \hline
		\textbf{E3}&0.0015&(0.003)&0.54&(0.24)&0.828&(0.34)   \\  \hline
		\textbf{E4}&0.0018&(0.003)&0.203&(0.068)&0.2997&(0.1)  \\  \hline
		\textbf{E5}& 1.249&(1.257)&1.276&(1.231)&1.288&(1.219)     \\  \hline 
		\textbf{E6}& 1.031&(0.853)&1.27&(0.834)&1.328&(0.819) \\  \hline
		% If possible, add standard deviation here - JJ
		% I could not find the original spreadsheet, I only have the raw data. I could 
		%%% not add standard deviation on time - Laura
		\hline
	\end{tabular}
	\caption{Summary of the results of the last generation in 15-20 runs for each
		experiment. 40 runs for E5 and E6.
		G: number of generations, E: experiment 
		number} % What
	% is E? Is that the average? Number of
	% generations up to what?
	% Also explain the importance of the
	% fitness as an evaluation of the
	% quality of the solutions - JJ
	% Also, average over what. Best individual in every experiment?
	% Last generation? - JJ
	% Modified caption. Better? - Laura
	\label{t:resOver2}
\end{table*}

\subsection{Removing game and penalizing gaps in Y-axis}\label{E5}

The main problem with the previous experiments was the time needed to
load the Science Birds simulation environment and run the levels,
which needed several seconds for loading and obtaining results. So the
main objective of this experiment was to find a way to get
rid of the in-game simulation. In order to do that, we will use a Physics engine
called Box2D \cite{catto2011box2d} that was used in the development of the original game.
Since game physics do not usually resemble real world physics we adjusted
the parameters so this simulation an the game behave in the same way.
As we can see in table \ref{t:resOver1} the execution time drastically
drops from 5 hours to less than 20 minutes on average, even running
more generations in the process.


This opened the way for performing more 
operations on the individuals. In this case we chose to penalize
not only the distance to the ground but also the \textit{gaps} in the
Y-axis, which will make objects drop and maybe break.
This will encourage individuals to grow vertically and not only horizontally
like in previous experiments. This changes the fitness function, so we
will have to compare by the actual obtained structure, one of which is
shown in Figure \ref{f:e5}.
%
 \begin{figure}
 	\centering
 	\includegraphics[scale=0.3]{E5.png}
 	\caption{One of the solutions from \ref{E5}}\label{f:e5}
      \end{figure}

In general, this penalization of gaps creates a faster path to stable
structures. Still, this path leads to mostly flat structures with 
some higher block in unstable positions, which
are structurally solid, but not interesting. One of the stable results is shown in figure \ref{f:e5}.
% Something more should have to be commented on these results - JJ

\subsection{Changing the evaluation function}\label{E6}

Observing results from the previous experiment we realized that what
evolution found was that laying many blocks on the ground was enough
to get a high fitness: the average speed was decreased and it will
place unstable blocks to cover gaps in Y-axis. In
order to correct this behaviour we changed the 
fitness function to take into account the fastest moving object:
$$fitness_{indV2} = \max{(V)}$$
Additionally, we initialized levels including one of a list of pre configured
blocks in addition to the random initialization used until
now.

This makes the fitness value depends on just one gene, although it can be a
different one each time. The improvement of solutions to find acceptable ones
slowed down % This would have to be proved by a chart
again, with a different fitness function we cannot compare the fitness
value with the rest of the experiments. 
 \begin{figure}
 	\centering
 	\includegraphics[scale=0.3]{E6.png}
 	\caption{One of the solutions from \ref{E6}}\label{f:e6}
 \end{figure}


 %Again, you can't simply show a single figure as a result. Maybe show
 %average height, or several best solutions. And always reference the
 %figure - JJ
%************************************************



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  CONCLUSIONS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section{Conclusions and Future Work} 
\label{sec:conclusions}

% ----- probably should be eliminated --- 
% Here, we briefly recap several aspects of the development of this project. 
% First, we reviewed the context of the problem: PCG. In section 
%\ref{sec:intro}, 
% we looked at the main reasons for its existence: from replacing human 
% creativity where it cannot reach (unlimited or personalized) to enhancing and 
% speeding the creative process. In some cases, PCG can  be considered a kind 
%of 
% creative expression for itself. The technical background to approach the 
% problem is discussed in section \ref{sec:soa}.
% --- up to here --

This paper was developed with the main objective of implementing a
competitive entry for the Angry Birds level generation contest, and  a
set of sub-objectives in mind: exploring the expressiveness and variability of 
SBPCG with evolutionary techniques, adapting the game to extract data from 
execution and producing stable structures under gravity, in a simulated environment.
% What the intro to the conclusion should say are the main objectives
% of this paper, and whether they have been, or not, achieved or to
% what extent - JJ

% Antonio - This is my Proposal for this paragraph
For this aim we have implemented an Evolutionary Algorithm able to optimize 
level structures to meet some criteria, being the main one the stability of the 
constructions.
%Perhaps the level of achievement of the first objective, exploring the 
%expressiveness and variability of 
%SBPCG with evolutionary techniques,
%is not as easily measurable as the other two. It could seem like
%this objective has not been fully accomplished: only one SBPCG method
%has been implemented and tested. However, it was not in the scope of
%this work to test SBPCG in general, but in this particular case, for
%this particular game.
Considering this, the method studied was
sufficiently general and flexible to draw some conclusions about the
topic. SBPCG methods are a potential good solution to offline content
generation but it requires a great amount of problem-specific
knowledge. Like any other form of creative work, the biggest issue may
be how to measure how good, creative or enjoyable is the piece. The
more rules the author adds, expressiveness starts to get lost as the
results are variations of the same idea. However, it is crystal clear
from the experiments run in this paper that a lack of knowledge
will lead to unexpected outcomes.
In our case, the fitness function used the 
stability of the structure and only considered other features--- overlapping 
blocks and distance to the ground--- to ensure the levels would be valid.
In experiment \ref{E5} and \ref{E6} height was also taken into account.

 % I am lost in this paragraph. It should be more
 % related to the actual experiments made - JJ

The second objective, adapting the game to extract data from execution, was 
certainly achieved. It was also a basic requirement to proceed with the rest of 
them. The game does provide the data, as long as the input is correctly 
structured. 
% Although the original intention was to make it available on Linux, 
% currently it can only be executed with the desired behaviour on Windows. 
% Antonio - I think this is not relevant
% Another issue is that the simulation is not easily adaptable. If the fitness 
% function of the EA is changed and needs data that is not included in the 
%output 
% right now, the game would have to be changed and compiled again. 
% Antonio - I would suggest this text instead
In order to conduct our experiments the Angry Birds simulator (Science Birds) 
has been adapted to our necessities, yielding now some  other information 
required to evaluate the individuals of the implemented EA. As this was a 
bottleneck, experiments \ref{E5} and \ref{E6} used only a physic simulation,
leaving behind the actual game.
It would be interesting to obtain other kind of data from both simulations,
such as the height of the structure and, eventually, its resistance to
bombardment by angry birds. However, this is left as future work.

Producing stable structures under gravity was the third objective and
the closest to the ultimate one. That objective was effectively
achieved, but the consequence of evolving in a path of minimum
movement or maximum stability results in structures that are close to
the ground and do not have more than a few floors , which could not be very 
exciting for the players. 
% Antonio - I would add:
% , which could not be very exciting for the players. 
% Tell me what you think of this.
% Floors is not precise. ..more than a few stacked blocks? - Mario 
The main issue is, then, how we evaluate the levels. In fact this is 
a matter of how we define what an Angry Birds' level \textit{is} and if that 
definition matches the fitness function.
%A lot of elements were correct, but the definition was not complete.
How this definition of level plays
with the paths of evolution is also a problem. Since we define as
level as a structure that is stable, evolution will maximize stability
finding, as in the beginnings of architectural practice, squat
structures that are neither aesthetically pleasing nor playable,
although undeniably sturdy and stable. We have been successful in,
evolving free form structures, to find these type. But once we get
there, we need to go into a different evolution mode that takes into
account several features as a multiobjective optimization problem:
stability is the first, but we can sacrifice a bit of stability for
height or some other aesthetic quality.

% This idea brings us to the last objective, that was not achieved. Without 
% results that match the definition of an Angry Birds level, placing the 
% remaining objects would not have made the level playable. The partial 
% achievement of the third goal, blocked the fourth one as this objective was 
% dependent on the third one.

To conclude on an optimistic tone, this work provides an interesting insight 
into the SBPCG, through the completion---and failure---of the goals we
set out to achieve at the beginning.

In order to improve the results of the method, different constraints could be 
expressed as multiple objectives. Overlapping blocks and velocity could 
be treated as minimization objectives and height as a maximization one. % but 
%of course we don't need
                                % to minimize height any more... - JJ
                                % Corrected - Laura

If we pay attention at the stages of evolution in this work, there is also 
room for improvement in the genetic operators. For example, the initialization 
produces a small amount of valid individuals which suggested that an elitist 
strategy for selection would work best. However, new experiments will help to 
better balance exploration and exploitation. An interesting addition
would be to add {\em building} operators that pile blocks on
structures that are already stable. % Check out this idea, Laura - JJ

\section{Acknowledgements}
 This paper has been supported in part by DeepBio
 (TIN2017-85727-C4-2-P) from the Ministerio de Economía y Competitividad
 in Spain.

\bibliographystyle{apalike}
{\small
\bibliography{angrybirds}}

\end{document}

